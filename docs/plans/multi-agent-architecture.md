# OpenClaw Multi-Agent Architecture

## Overview

Self-built, production-oriented, gateway-driven subagent system. Agents are config-defined (not code classes), each runs in an isolated session, results push-announced automatically.

## Key Files

- `src/agents/agent-scope.ts` — Agent config resolution (id, model, workspace, skills, subagents)
- `src/agents/subagent-spawn.ts` — `spawnSubagentDirect()`: depth/concurrency/permission checks → create session → inject system prompt → start agent run → register
- `src/agents/subagent-registry.ts` — In-memory Map + disk persistence; lifecycle listener via `onAgentEvent()`; completion wait via `agent.wait` RPC; sweeper for archive cleanup
- `src/agents/subagent-registry.types.ts` — `SubagentRunRecord` type
- `src/agents/subagent-announce.ts` — `runSubagentAnnounceFlow()`: read child output → build announce message → deliver via steered/queued/direct path → cleanup
- `src/agents/subagent-depth.ts` — Depth tracking from session store
- `src/agents/lanes.ts` — `AGENT_LANE_SUBAGENT` (CommandLane.Subagent)
- `src/agents/openclaw-tools.ts` — Full tool suite assembly including `sessions_spawn` and `subagents` tools
- `src/routing/session-key.ts` — Session key format: `agent:<agentId>:<sessionId>`

## Agent Definition (Config-Driven)

```
agents.list[]: { id, name, default, workspace, model, skills, subagents, tools, sandbox, identity, groupChat }
agents.defaults: { workspace, model, subagents: { maxSpawnDepth, maxChildrenPerAgent, thinking } }
```

## Subagent Lifecycle

1. **Spawn**: `sessions_spawn` tool → `spawnSubagentDirect()` → depth check (default max via `DEFAULT_SUBAGENT_MAX_SPAWN_DEPTH`) → concurrency check (default 5) → permission check (`allowAgents`) → create child session → inject subagent system prompt → `callGateway({ method: "agent" })` → register in registry
2. **Run**: Child runs independently in its own session with full tool suite
3. **Complete**: Gateway lifecycle event (end/error) → `completeSubagentRun()` → persist outcome
4. **Announce**: `runSubagentAnnounceFlow()` → read latest child output → deliver to parent via three paths:
   - **steered**: inject into parent's active LLM context
   - **queued**: enqueue for when parent is idle
   - **direct**: send via gateway `agent` RPC (new turn)
5. **Cleanup**: Delete child session or archive (sweeper at 60min default)

## Spawn Modes

- `run` (default): one-shot, session cleaned after completion
- `session`: persistent, thread-bound, survives across follow-up messages

## Tree Structure

```
Main Agent (depth=0)
├── Subagent A (depth=1) — can spawn further if depth < maxSpawnDepth
│   ├── Subagent A1 (depth=2) — leaf if at max depth
│   └── Subagent A2 (depth=2)
├── Subagent B (depth=1)
└── Subagent C (depth=1)
```

## Communication: Gateway RPC

- `sessions.patch` — create/update session
- `agent` — trigger agent run
- `agent.wait` — cross-process wait for completion
- `chat.history` — read conversation history
- `sessions.delete` — cleanup
- `send` — direct message delivery

## Resilience

- Registry persisted to disk, restored on gateway restart
- Announce retries with exponential backoff (max 3 attempts, 5min expiry)
- Parent session gone → bubble result to grandparent
- Steer/restart → suppress old announce via `suppressAnnounceReason`

## Tool Suite (per agent, including subagents)

`sessions_spawn`, `subagents`, `message`, `browser`, `canvas`, `cron`, `web_search`, `web_fetch`, `image`, `sessions_list/history/send`, `gateway`, `tts`, `nodes`, `agents_list`, `session_status`, + plugin tools

## Subagent System Prompt Template

Generated by `buildSubagentSystemPrompt()`:

- States role as subagent with specific task
- Rules: stay focused, complete task, don't initiate, be ephemeral, trust push-based completion
- If depth allows: can spawn own sub-agents
- If leaf: cannot spawn further
- Final output auto-reported to parent
